Solve() 完成解題時，會輸出結果。可是負責出題的 GiveQuestion() 程式裡使用的DigMap()，
運用了 Solve() 來試求解，卻不希望Solve() 輸出結果，所以宣告了data member out，讓 Solve()
用out 控制是否輸出結果。out ==0 時不輸出結果，out==1時輸出結果。Sudoku物件初建立時，
建構函數會將out設為1。

DigMap() 程式一進入就將out設為0，離開前再將out設為1。

PrintMap() 輸出數獨內容到螢幕
-----------------------------------
solve()

程式對map陣列裡的內容進行解題。將答案數ansNum設為0，取得第1個空白的位置，進入解題迴圈。

在解題迴圈裡，完成目前位置的填數後，就把這個位置放入prevPos stack中，再取得下一個空白位置，
繼續解題迴圈。如果目前位置的填數失敗，將本位置的內容重設為空白，再從prevPos stack中取得上一
個位置，回到上一個位置繼續測試。

當得到解答後，ansNum++。要進行下一次解題，以得知是否有第2解前，先用board陣列保存map的內容，
再進行下一次解題。否則進行下一次解題後，map的內容已改變。

當無法再求解（下一個空白位置<0），或ansNum==2（已知有第2解），就離開解題迴圈。然後依據ansNum
的內容輸出結果。

-----------------------------------
GiveQuestion()

隨機產生4個宮行位置不相同的黑色區塊，將4個宮行位置存在dark陣列。dark原來存的是各宮格列的黑色
區塊之宮行位置，需轉換成實際的宮數，再存回dark陣列。map內容先歸零，然後將4個黑色區塊的所有格子填入-1。

接著產生完整數獨盤面。填數迴圈從1填到9。每填1個數字時，都從第0宮填到第15宮，但要跳過黑色區塊
的宮。每宮每次只填1個數字，而且要填入宮格內的那個位置，都是隨機選取的。產生完整數獨盤面後，
就交由DigMap()處理。

DigMap()是採用挖洞法來產生數獨題目。先將map內容存入board中，並且依序把有效格子(內容!=-1)的位
置存入effGrid陣列中，共有144 - 36 = 108個有效格子。接著進入挖洞迴圈。迴圈裡針對effGrid陣列所存位
置進行挖洞。因為effGrid陣列中存放的位置，都是有效的格子，所以不會挖到黑色區塊的格子。而且挖洞的
位置也是隨機的。每進行1次挖洞，就把挖洞後的結果交給Solve()求解。如果有多重解，剛挖的洞需填回，
繼續進行下一挖洞迴圈。離開挖洞迴圈後就完成數獨題目了。

把數獨題目輸出到螢幕。



